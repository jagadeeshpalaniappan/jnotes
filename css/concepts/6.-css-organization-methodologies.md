---
description: '(BEM, OOCSS, SMACSS)'
---

# 1. CSS Organization Methodologies

## CSS Organization Methodologies 

```text
## OOCSS 
    - CSS ‘object’ as "a repeating visual pattern"
    - Sepearte: 'Structure & Skin' , Sepearte: 'Container & Content'

## BEM
    - Naming Rules
    - Block1__Elem1--Modif1
    
- SMACSS
- ITCSS

- Functional CSS
- CSS Modules
```

{% tabs %}
{% tab title="BEM" %}
{% embed url="https://www.youtube.com/watch?v=SLjHSVwXYq4" %}
{% endtab %}

{% tab title="OOCSS, SMACSS, BEM" %}
{% embed url="https://www.youtube.com/watch?v=IKFq2cSbQ4Q" %}
{% endtab %}

{% tab title="Functional CSS" %}


{% embed url="https://www.youtube.com/watch?v=aCQj7ry4Sns" %}
{% endtab %}

{% tab title="CSS Modules" %}
{% embed url="https://www.youtube.com/watch?v=u9LBSeeJzXc" %}
{% endtab %}

{% tab title="CSS Modules vs BEM" %}


{% embed url="https://www.youtube.com/watch?v=AFphQugooXQ" %}
{% endtab %}
{% endtabs %}

## **1. OOCSS — 'Object Oriented' - CSS**

* Object Oriented
  * procedural backend code vs Object-Oriented backend code
  * classic CSS vs OOCSS
* * This methodology is based on two basic principles: 
  1. **Separation of `Structure` and `Skin`**
     * **structure:**  height, width, margin, padding, overflow,...
     * **skin:** fonts, color, background, shadows, gradients
  2. **Separation of `Container` and `Content`:** 
     * Container: A  block or wrapper element that has as one or many child elements inside
     * Content: Child component part of a Container
* * _CSS ‘object’ as `"a repeating visual pattern"`, that can be abstracted into an **independent snippet** of HTML and CSS code. That object can then be reused throughout a site_
* * OOCSS focuses on flexible, modular, swappable components that do 'One Thing Well'. 
* OOCSS focuses on the 
  * [Single Responsibility Principle](http://en.wikipedia.org/wiki/Single_responsibility_principle)
    * **No matter where you put, "object should look the same"**
  * [Separation of Concerns](http://en.wikipedia.org/wiki/Separation_of_concerns), 
    * **Separation of Structure and Skin**
    * **Separation of Container and Content**
  * and much more of the foundational concepts of Object Oriented Programming

For a great introduction to OOCSS, [this post on the OOCSS Media Object](http://www.stubbornella.org/content/2010/06/25/the-media-object-saves-hundreds-of-lines-of-code/), it shows an example of what a CSS object looks like, and some of the benefits of using one.

Here's a sample, from that post, of an OOCSS object:

```text
.media {}
.media .img {}
.media .img img {}
.media .imgExt {}
.bd {}
```

As you can see, `.media` is an object, and the goal is to make that object independent of its surroundings so that it can be placed anywhere in your site. 

> No matter where you put, "**`object should look the same`**"



Note: In contrast to the rest of the methodologies we will see after OOCSS, this one does not establish rules when naming classes, as well as it does not offer suggestions on whether to use IDs and tags or not, at the time of give style. Despite this lack of rules, the principles of this method invite us to deduce how to use these features. That is why, BEM is nowadays considered to be the perfect complement for OOCSS methodology.

## 2. BEM \(Block\_\_Element--Modifier\) <a id="9b46"></a>

* BEM may be defined as a concrete application of OOCSS. 
* It tries to address the **`naming issue`** 
  * by suggesting a structured way of naming classes, based on properties
* * **BEM uses only classes:** Blocks, Elements, Modifiers are defined by class selectors.
* **BEM does not use** HTML tags or IDs as selectors
  * it doesn't use class connected to a HTML tag, 

{% tabs %}
{% tab title="Pseudo code" %}
```css
/* 
#### Block: #### 
- Block is the 'root' of particular component (or css object)
- It can work independent. It is self-contained starting context 
- It can have any number of 'Elements'. It can also carry 'Modifiers'.
*/
.block {}

/* 
#### Element: #### 
- Element is a child component (part of a Block)
- It cannot work independent. - It always works properly with appropriate parent 'Block'
- An element inherits styes. It can also carry Modifiers.
*/
.block__elem1 {}
.block__elem2 {}
.block__elem3 {}


/* 
#### Modifier: #### 
- Denoted by two hyphens.
- A variation of a Block or Element. 
- These extend styles.
*/

.block__elem1--modif1 {}
.block__elem1--modif2 {}
.block__elem1--modif3 {}

.block--modif1 {}
.block--modif2 {}
```



```markup
<div class="block">
    <div class="block__elem1">
        <div class="block__elem2"></div>
    </div>

    <div class="block__elem3"></div>
</div>

<div class="block--modif1">
    <div class="block__elem1">
        <div class="block__elem2"></div>
    </div>

    <div class="block__elem3"></div>
</div>
```
{% endtab %}

{% tab title="Example" %}
```css
/* #### Block: #### */

.card {}
.list {}

/* #### Element: #### */

.card__header {}
.card__body {}
.card__footer {}

.list__item {}

/* #### Modifier: #### */

.card--darktheme {}
.card--disabled {}
.card--big {}

.card__header--special {}
.card__body--special {}
.card__footer--special {}

.list--darktheme {}
.list__item--active {}

```



```markup
<div class="card">
    <div class="card__body">
        <h2> I'm a light card</h2>
        <p> And .....</p>
    </div>
</div>

<div class="card card--darktheme">
    <div class="card__body">
        <h2> I'm a light card</h2>
        <p> And .....</p>
    </div>
</div>
```

![](../../.gitbook/assets/image%20%28164%29.png)
{% endtab %}
{% endtabs %}



**SMACSS — Scalable and Modular Architecture for CSS**

SMACSS method consists on organizing CSS rules and five different categories.:

* **Basic**: Default styles. These include tags selectors, although sometimes it could include attributes, pseudo-elements and child and parent selectors. A good equivalent would be the common reset.css or normalize.css.
* **Layout**: It divides the content into sections, understanding that in each section the content would be divided into modules. It would the same as using containers or a grid.
* **Module**: Those components that can be reused.
* **State**: The rules that establish the state of our modules. An example would be the active state of a button. States also include modules states according to where that module is inside the page.
* **Theme**: This last category is an optional one. It would allow the more visual aspects of the project, keeping in mind that these aspects could be already included in other categories, but because of the project nature are separated into a different theme to use them properly.

SMACSS does define CSS naming rules:

* Prefix l- or layout- for layout rules.
* Prefix module- for modules.
* Prefix is- for states.

The whole methodology is developed and explained by its author a[ free book](https://smacss.com/).

From these methodologies, others emerged like [**Systematic CSS**](http://www.systematicwebdesign.com/)**,** that has features from the three previous one, or [**SUIT CSS**](https://suitcss.github.io/), the result of BEM methodology, task automation and development with frameworks like React, Angular or Ember.

Which is the best one? There is no simple answer, each developer would choose the appropriate one according to what each project needs or his/her way of work. When it gets to the bottom of the matter, all of them follow the same ‘good practice’ policy.

The important thing is that every one of them looks for the essential in a big project: scalability and good maintenance, and the combination of both, therefore we should not take them as manual books, but instead as tools to improve our code and with it, our projects.





