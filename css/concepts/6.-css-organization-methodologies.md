---
description: '(BEM, OOCSS, SMACSS)'
---

# 1. CSS Organization Methodologies

## CSS Organization Methodologies 

* OOCSS, SMACSS, 
* BEM
* ITCSS
* * Functional CSS
* CSS Modules

{% tabs %}
{% tab title="BEM" %}
{% embed url="https://www.youtube.com/watch?v=SLjHSVwXYq4" %}
{% endtab %}

{% tab title="OOCSS, SMACSS, BEM" %}
{% embed url="https://www.youtube.com/watch?v=IKFq2cSbQ4Q" %}
{% endtab %}

{% tab title="Functional CSS" %}


{% embed url="https://www.youtube.com/watch?v=aCQj7ry4Sns" %}
{% endtab %}

{% tab title="CSS Modules" %}
{% embed url="https://www.youtube.com/watch?v=u9LBSeeJzXc" %}
{% endtab %}

{% tab title="CSS Modules vs BEM" %}


{% embed url="https://www.youtube.com/watch?v=AFphQugooXQ" %}
{% endtab %}
{% endtabs %}

## **1. OOCSS — 'Object Oriented' - CSS**

* Object Oriented
  * procedural backend code vs Object-Oriented backend code
  * classic CSS vs OOCSS
* * This methodology is based on two basic principles: 
  1. **Separation of `Structure` and `Skin`**
     * **structure:**  height, width, margin, padding, overflow,...
     * **skin:** fonts, color, background, shadows, gradients
  2. **Separation of `Container` and `Content`:** 
     * Container: A  block or wrapper element that has as one or many child elements inside
     * Content: Child component part of a Container
* * _CSS ‘object’ as `"a repeating visual pattern"`, that can be abstracted into an **independent snippet** of HTML and CSS code. That object can then be reused throughout a site_
* * OOCSS focuses on flexible, modular, swappable components that do 'One Thing Well'. 
* OOCSS focuses on the 
  * [Single Responsibility Principle](http://en.wikipedia.org/wiki/Single_responsibility_principle)
    * **No matter where you put, "object should look the same"**
  * [Separation of Concerns](http://en.wikipedia.org/wiki/Separation_of_concerns), 
    * **Separation of Structure and Skin**
    * **Separation of Container and Content**
  * and much more of the foundational concepts of Object Oriented Programming

For a great introduction to OOCSS, [this post on the OOCSS Media Object](http://www.stubbornella.org/content/2010/06/25/the-media-object-saves-hundreds-of-lines-of-code/), it shows an example of what a CSS object looks like, and some of the benefits of using one.

Here's a sample, from that post, of an OOCSS object:

```text
.media {}
.media .img {}
.media .img img {}
.media .imgExt {}
.bd {}
```

As you can see, `.media` is an object, and the goal is to make that object independent of its surroundings so that it can be placed anywhere in your site. 

> No matter where you put, "**`object should look the same`**"



{% tabs %}
{% tab title="1.Separation of \'Structure\' and \'Skin\'" %}
1. **Separation of Structure and Skin**

```css
/* WRONG */
/*
<a class="btn-1" href="#">Pink Button</a>
<a class="btn-2" href="#">Blue Button</a>
*/

.btn-1 {
    width: 150px;
    height: 50px;
    background: deeppink;
    color: #fff;
    border-radius: 5px;
}

.btn-2 {
    width: 150px;
    height: 50px;
    background: deepskyblue;
    color: #000;
    border-radius: 5px;
}
```



```css
/* CORRECT */
/*
<a class="btn btn-pink" href="#">Pink Button</a>
<a class="btn btn-blue" href="#">Blue Button</a>
*/

/* Btn Structure */
.btn {
    width: 150px;
    height: 50px;
    border-radius: 5px;
}

/* Btn Skins */
.btn-pink {
    background: deeppink;
    color: #fff;
}

.btn-blue {
    background: deepskyblue;
    color: #000;
}
```
{% endtab %}

{% tab title="2.Separation of \'Container\' and \'Content\'" %}
**2.Separation of Container and Content:**

As a general rule, styles should never be scoped to particular containers. Otherwise, you’ll be unable to reuse them without applying overrides. 

For example, below is the standard way of setting up the elements that make up a sidebar:

```css
/* WRONG */

#sidebar {
    padding: 2px;
    left: 0;
    margin: 3px;
    position: absolute;
    width: 140px;
}


#sidebar .list {
    margin: 3px;
}


#sidebar .list .list-header {
    font-size: 16px;
    color: #FFF;
    background-color: red;
}


#sidebar .list .list-body {
    font-size: 12px;
    color: #eee;
}
```

---------------

Now, here are the same coding instructions with the `container` and `content` separated:

* `.sidebar` is container for `.list` content
* `.list` is container for `.list-header` and `.list-body` content

```css
.sidebar {
    padding: 2px;
    left: 0;
    margin: 3px;
    position: absolute;
    width: 140px;
}

.list {
    margin: 3px;
}

.list-header {
    font-size: 16px;
    color: #FFF;
    background-color: red;
}

.list-body {
    font-size: 12px;
    color: #eee
}
```

* Avoiding child selectors is a good strategy for maintaining separation between container and content. Be sure to bestow **unique classes to unique elements**.
{% endtab %}
{% endtabs %}

* OOCSS is all about **abstraction** and **reusability**. 
* That should give you smaller files, reduce duplication and keep everything easy to maintain.
* Also OOCSS has this nice concept of the **performance freebies**_:_ every time you reuse something in your CSS, you’re essentially creating new styled elements with zero lines of CSS code. Sounds great.

Note:

* In contrast to the rest of the methodologies we will see after OOCSS, this one does not establish rules when naming classes, as well as it does not offer suggestions on whether to use IDs and tags or not, at the time of give style. Despite this lack of rules, the principles of this method invite us to deduce how to use these features. That is why, BEM is nowadays considered to be the perfect complement for OOCSS methodology.

## 2. BEM \(Block\_\_Element--Modifier\) <a id="9b46"></a>

* BEM may be defined as a concrete application of OOCSS. 
* It tries to address the **`naming issue`** 
  * by suggesting a structured way of naming classes, based on properties
* * **BEM uses only classes:** Blocks, Elements, Modifiers are defined by class selectors.
* **BEM does not use** HTML tags or IDs as selectors
  * it doesn't use class connected to a HTML tag, 



{% tabs %}
{% tab title="Pseudo code" %}
```css
/* 
#### Block: #### 
- The root of a piece of particular component.  
- It is a self-contained starting context 
- and can have any number of Elements or Modifiers associated with it.
*/
.block {}

/* 
#### Element: #### 
- Denoted by two underscores. 
- A child component part of a Block. 
- An element inherits styes. It can also carry Modifiers.
*/
.block__elem1 {}
.block__elem2 {}
.block__elem3 {}


/* 
#### Modifier: #### 
- Denoted by two hyphens.
- A variation of a Block or Element. 
- These extend styles.
*/

.block__elem1--modif1 {}
.block__elem1--modif2 {}
.block__elem1--modif3 {}

.block--modif1 {}
.block--modif2 {}
```



```markup
<div class="block">
    <div class="block__elem1">
        <div class="block__elem2"></div>
    </div>

    <div class="block__elem3"></div>
</div>

<div class="block--modif1">
    <div class="block__elem1">
        <div class="block__elem2"></div>
    </div>

    <div class="block__elem3"></div>
</div>
```
{% endtab %}

{% tab title="Example" %}
```css
/* #### Block: #### */

.card {}
.list {}

/* #### Element: #### */

.card__header {}
.card__body {}
.card__footer {}

.list__item {}

/* #### Modifier: #### */

.card--darktheme {}
.card--disabled {}
.card--big {}

.card__header--special {}
.card__body--special {}
.card__footer--special {}

.list--darktheme {}
.list__item--active {}

```



```markup
<div class="card">
    <div class="card__body">
        <h2> I'm a light card</h2>
        <p> And .....</p>
    </div>
</div>

<div class="card card--darktheme">
    <div class="card__body">
        <h2> I'm a light card</h2>
        <p> And .....</p>
    </div>
</div>
```

![](../../.gitbook/assets/image%20%28164%29.png)
{% endtab %}
{% endtabs %}









