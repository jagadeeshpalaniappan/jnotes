# 1. JavaScript - Tricky Qstns

This is a normal paragraph following a header. mark works fine. gitbook

Check it out:

\[codetabs height=220 src="bubble-target"\]

It's possible that `event.target` equals `this` -- when the click is made directly on the `<form>` element.

```markup
<td>
  cool
*!*
  <strong>special</strong>
*/!*
  cool
  ...
</td>
```

## 1.

```javascript
console.log(2 + '2'); // 22
console.log(2 - '2'); // 0
```

## 2. Remove duplicates from Array \(OneLiner\)

```javascript
let inputNums = [1,2,2,3];

// Array to Set
let set = new Set(inputNums);
console.log(set); // 1,2,3

// Set to Array:
console.log([...set]); // [1,2,3]

// OneLiner:
console.log([...new Set(inputNums)]); // [1,2,3]
```

## 3. let vs var

```javascript
let myFn = function() {
  {
    let l = 'let';
    var v = 'var';
  }

  console.log(v);
  console.log(l);
}
```

Make 'v' as block scope, \(condn: do not change 'var'\)

```javascript
let myFn = function() {

   {

    (function() {
      let l = 'let';
      var v = 'var';
     })();  

   }

  console.log(v);
  console.log(l);
}
```

## 4.

```javascript
console.log(5 < 6 < 7); // true
console.log(7 > 6 > 5); // false  // why ?

console.log(5 < 6 < 7); 
console.log((5 < 6) < 7);
console.log( true < 7); // since < or > operator 'true' gets converted into '1'
console.log(1 < 7); // true



console.log(7 > 6 > 5);
console.log((7 < 6) < 5);
console.log( true < 5); // since < or > operator 'true' gets converted into '1'
console.log(1 < 5); // false
```

## 5.

```javascript
let myFn = function() { return arguments[0]; };
console.log(myFn('hi')); // 'hi'

let myFn = () => arguments[0];
console.log(myFn('hi')); // ReferenceError: arguments is not defined

// Arrow fn does not support 'arguments'

// Use Spread Operator:

let myFn = (...args) => args[0];
console.log(myFn('hi')); // ['hi']
console.log(myFn('hi', 'hello')); // ['hi', 'hello']
```

## 6.

```javascript
let myFn = function() { 
  return
  {
    msg: 'hi'
  }
};
console.log(myFn()); // undefined


// After Fix: 

let myFn = function() { 
  return {
    msg: 'hi'
  }
};

console.log(myFn()); // { msg: 'hi' }
// because, javascript doesn't need semicolon to end the line.
```

## 7.

```javascript
let myObj = {
  name: 'jagadeesh'
}
myObj.age = 22;  // works fine
myObj.name = 'jagadeesh palaniappan';  // works fine

console.log(myObj); { name: 'jagadeesh palaniappan', age: 22 }
```

How do u stop allowing user to add new property  
E.g.

* do not allow user to add new property 'age'

```javascript
let myObj = {
  name: 'jagadeesh'
}

Object.seal(myObj); // 'Object.seal' doesn't allow user to add new proeprty

myObj.age = 22;  // does nothing
myObj.name = 'jagadeesh palaniappan';  // works fine

console.log(myObj); { name: 'jagadeesh palaniappan' }
```

How do u stop allowing user to add new property and modify existing property  
E.g.

* do not allow user to add new property 'age'
* do not allow user to modify existing property 'name'

```javascript
let myObj = {
  name: 'jagadeesh'
}

Object.freeze(myObj); // 'Object.freeze' doesn't allow user to add new proeprty & property value cannot be updated

myObj.age = 22;  // does nothing
myObj.name = 'jagadeesh palaniappan';  // does nothing

console.log(myObj); // { name: 'jagadeesh' }
```

How do u stop allowing user to modify existing property \(but allow, adding new property\)  
E.g.

* allow user to add new property 'age'
* do not allow user to modify existing property 'name'

```javascript
let myObj = {
  name: 'jagadeesh'
}

Object.defineProperty(myObj, 'age', { value: 22, writable: false }); 
// 'Object.defineProperty' doesn't allow user to add new proeprty & property value cannot be updated

myObj.age = 33;  // does nothing
myObj.name = 'jagadeesh palaniappan';  // does nothing

console.log(myObj); // { name: 'jagadeesh palaniappan', age: 22 }
```

## 8.

```javascript
console.log(Math.max(1,5,2)); // 5
console.log(Math.max()); // -Infinity // why?

/* 
Math.max(1,5,2)
 - picks the lowest possible value in the Math (-Infinity) and compares with 1 ==> 1 is greater
 - picks 1 and compares with 5 ==> 5 is greater
 - picks 5 and compares with 2 ==> 5 is greater 

Math.max()
  - picks the lowest possible value in the Math (-Infinity) and compares with nothing ==> -Infinity is the answer
*/
```

## 9.

```javascript
const myArr = [1,2,3];
myArr[-1] = -1;

console.log(myArr[myArr.indexOf(10000)]);  // -1  // how?


console.log(myArr.indexOf(10000));  // since '10000' not available in myArr, it returns '-1'

console.log(myArr[-1]);  // we already set the myArr[-1] as '-1'
```

## 10.

```javascript
const myArr = [1,2,15,30,5,45,7];
console.log(myArr.sort()); // [1,15,2,30,45,5,7]   // why?  // becoz javascript 'sort' them as 'string' not 'numbers'

// how do u fix this?
// Now 'sort' compares them as 'Number'
// Ascending Order:
console.log(myArr.sort(function(a, b) { return a > b; }));  // [1, 2, 5, 7, 15, 30, 45] 

// Descending Order:
console.log(myArr.sort(function(a, b) { return a < b; }));  // [45, 30, 15, 7, 5, 2, 1]
```

## 11.

```javascript
// let i = ?  

// find 'i': result should come like this
console.log(i + 1); // 1
console.log(i - 1); // -1
console.log(i * i); // 0
console.log(i / i); // 1

// Lets try using '0'
let i = 0;

console.log(i + 1); // 1
console.log(i - 1); // -1
console.log(i * i); // 0
console.log(i / i); // NaN  // expected: 1


// Answer is Number.MIN_VALUE  (this is very close to zero, but NOT zero)

let i = Number.MIN_VALUE;
console.log(i + 1); // 1
console.log(i - 1); // -1
console.log(i * i); // 0
console.log(i / i); // 1
```

## 12.

```javascript
let x = [1,2,3] + [4,5,6];
console.log(x); // 1,2,34,5,6   // why? 
// becoz '+' operator works with 'string' or 'number'
// if it is NOT a 'string' or 'number', it will try to convert into them
// [1,2,3] cannot be converted as 'number', can be converted as 'string'
// same for [4,5,6]
// '1,2,3' + '4,5,6'  ==> 1,2,34,5,6


// Change little code, to make it work normal
let x = [...[1,2,3], ...[4,5,6]];
console.log(x); // [1,2,3,4,5,6]
```

## 13.

```javascript
// print 18 --> '5's
console.log(555555555555555555);  // 555555555555555600  // why?

// becoz it crossed the maximum allowed integere in javascript
// In JavaScript -- max allowed integer is (16 digit)
console.log(Number.MAX_SAFE_INTEGER);  // 9007199254740991

// if u go beyond max allowed digits, it will simoly put 'zeros'
// 555555555555555555
// 9007199254740991
// 555555555555555600
```

## 14.

```javascript
(function() {
  var a = b = 100;
})();

console.log(b); // 100  
console.log(a); // ReferenceError: a is not defined

// why? 
// 'a' is declared inside the iife, but whereas 'b' is attached to 'global' scope

(function() {
  var a = b;
  b = 100;  // 'b' is not decalred, it will automatically attaches to 'global' scope
})();
```

## 15.

```javascript
console.log(NaN === NaN); // false // why?

// Ans2 : IEEE 754 spec says that NaNs are never equal.
```

## 16. Spread Operator

```javascript
let x = [1,2,3,4];
let y = x;  // 'y' is just a reference of 'x', if u change 'y' --> 'x' also changes

// We need copy of this, (Shallow Copy)
let x = [1,2,3,4];
let y = Object.assign([], x); // assigning values to new array 

// another way to do this, 'spread operator'
let x = [1,2,3,4];
let y = [...x];


// how i visualize this spread operator is,
/*
...x = 1,2,3,4
...y = 5,6,7

...x, ...y = 1,2,3,4,5,6,7
[ ...x, ...y ] = [ 1,2,3,4,5,6,7 ]
*/

let x = [1,2,3,4]
let y = [5,6,7]
console.log([...x, ...y]);   // [1,2,3,4,5,6,7]

// it is simmilar to
console.log(x.concat(y));    // [1,2,3,4,5,6,7]
console.log(x.concat(...y)); // [1,2,3,4,5,6,7]


let inputArr = [1,2,3];
let myFn = function(...args) {
  console.log(args);
}

myFn(inputArr); // [1,2,3]
```

In olden days, before ES6 - we do this way

```javascript
let inputArr = [1,5,2];
console.log(Math.max.apply(null, inputArr));  // 5
console.log(Math.max(...inputArr)); // 5

console.log(Math.max(inputArr)); // NaN // becoz, it is not expecting arg as 'Array' type, it is expecting 'Number' type
```

## 17.

```javascript

```

